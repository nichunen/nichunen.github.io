<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>倪春恩的博客</title>
  
  <subtitle>倪春恩的博客</subtitle>
  <link href="http://nichunen.github.io/atom.xml" rel="self"/>
  
  <link href="http://nichunen.github.io/"/>
  <updated>2023-02-01T13:18:24.343Z</updated>
  <id>http://nichunen.github.io/</id>
  
  <author>
    <name>Ni Chunen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>offer-43</title>
    <link href="http://nichunen.github.io/2023/02/01/offer-43/"/>
    <id>http://nichunen.github.io/2023/02/01/offer-43/</id>
    <published>2023-02-01T09:48:48.000Z</published>
    <updated>2023-02-01T13:18:24.343Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一个整数 &lt;code&gt;n&lt;/code&gt; ，求1～n这n个整数的十进制表示中1出现的次数。&lt;/p&gt;
&lt;p&gt;例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>How to setup debugging environment for Kylin5 locally</title>
    <link href="http://nichunen.github.io/2023/01/31/kylin-5-debug/"/>
    <id>http://nichunen.github.io/2023/01/31/kylin-5-debug/</id>
    <published>2023-01-31T08:44:33.000Z</published>
    <updated>2023-02-01T09:48:53.937Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;1-Check-Software-Requirement&quot;&gt;&lt;a href=&quot;#1-Check-Software-Requirement&quot; class=&quot;headerlink&quot; title=&quot;1. Check Software</summary>
        
      
    
    
    
    <category term="bigdata" scheme="http://nichunen.github.io/categories/bigdata/"/>
    
    
    <category term="kylin" scheme="http://nichunen.github.io/tags/kylin/"/>
    
  </entry>
  
  <entry>
    <title>offer-42</title>
    <link href="http://nichunen.github.io/2023/01/31/offer-42/"/>
    <id>http://nichunen.github.io/2023/01/31/offer-42/</id>
    <published>2023-01-31T03:31:36.000Z</published>
    <updated>2023-01-31T05:44:12.372Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;要求时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-41</title>
    <link href="http://nichunen.github.io/2023/01/30/offer-41/"/>
    <id>http://nichunen.github.io/2023/01/30/offer-41/</id>
    <published>2023-01-30T11:50:18.000Z</published>
    <updated>2023-01-30T14:53:57.900Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-40</title>
    <link href="http://nichunen.github.io/2023/01/29/offer-40/"/>
    <id>http://nichunen.github.io/2023/01/29/offer-40/</id>
    <published>2023-01-29T03:14:32.000Z</published>
    <updated>2023-01-29T05:39:57.577Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入整数数组 &lt;code&gt;arr&lt;/code&gt; ，找出其中最小的 &lt;code&gt;k&lt;/code&gt; 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-39</title>
    <link href="http://nichunen.github.io/2023/01/28/offer-39/"/>
    <id>http://nichunen.github.io/2023/01/28/offer-39/</id>
    <published>2023-01-28T06:03:30.000Z</published>
    <updated>2023-01-28T09:14:21.900Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-37</title>
    <link href="http://nichunen.github.io/2023/01/20/offer-37/"/>
    <id>http://nichunen.github.io/2023/01/20/offer-37/</id>
    <published>2023-01-20T03:25:33.000Z</published>
    <updated>2023-01-20T08:15:28.736Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树。&lt;/p&gt;
&lt;p&gt;你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 /</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-36</title>
    <link href="http://nichunen.github.io/2023/01/19/offer-36/"/>
    <id>http://nichunen.github.io/2023/01/19/offer-36/</id>
    <published>2023-01-19T03:14:31.000Z</published>
    <updated>2023-01-20T03:28:23.978Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt;为了让您更好地理解问题，以下面的二叉搜索树为例：&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-35</title>
    <link href="http://nichunen.github.io/2023/01/18/offer-35/"/>
    <id>http://nichunen.github.io/2023/01/18/offer-35/</id>
    <published>2023-01-18T03:24:51.000Z</published>
    <updated>2023-01-18T03:49:06.051Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请实现 &lt;code&gt;copyRandomList&lt;/code&gt; 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 &lt;code&gt;next&lt;/code&gt; 指针指向下一个节点，还有一个 &lt;code&gt;random&lt;/code&gt; 指针指向链表中的任意节点或者</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-34</title>
    <link href="http://nichunen.github.io/2023/01/17/offer-34/"/>
    <id>http://nichunen.github.io/2023/01/17/offer-34/</id>
    <published>2023-01-17T09:15:46.000Z</published>
    <updated>2023-01-18T03:25:08.144Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数目标和 &lt;code&gt;targetSum&lt;/code&gt; ，找出所有 &lt;strong&gt;从根节点到叶子节点&lt;/strong&gt;</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-33</title>
    <link href="http://nichunen.github.io/2023/01/16/offer-33/"/>
    <id>http://nichunen.github.io/2023/01/16/offer-33/</id>
    <published>2023-01-16T03:33:05.000Z</published>
    <updated>2023-01-17T09:15:35.467Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。假设输入的数组的任意两个数字都互不相同。&lt;/p&gt;
&lt;p&gt;参考以下这颗二叉搜索树：&lt;/p&gt;
&lt;pre</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-32-3</title>
    <link href="http://nichunen.github.io/2023/01/15/offer-32-3/"/>
    <id>http://nichunen.github.io/2023/01/15/offer-32-3/</id>
    <published>2023-01-15T03:27:52.000Z</published>
    <updated>2023-01-15T05:48:25.708Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树:</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-32-2</title>
    <link href="http://nichunen.github.io/2023/01/13/offer-32-2/"/>
    <id>http://nichunen.github.io/2023/01/13/offer-32-2/</id>
    <published>2023-01-13T03:23:46.000Z</published>
    <updated>2023-01-13T03:54:34.435Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;
&lt;pre class=&quot;line-numbers</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-32</title>
    <link href="http://nichunen.github.io/2023/01/12/offer-32/"/>
    <id>http://nichunen.github.io/2023/01/12/offer-32/</id>
    <published>2023-01-12T02:58:17.000Z</published>
    <updated>2023-01-12T06:18:03.731Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;
&lt;pre class=&quot;line-numbers</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-31</title>
    <link href="http://nichunen.github.io/2023/01/11/offer-31/"/>
    <id>http://nichunen.github.io/2023/01/11/offer-31/</id>
    <published>2023-01-11T07:28:15.000Z</published>
    <updated>2023-01-11T14:51:01.984Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2}</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-30</title>
    <link href="http://nichunen.github.io/2023/01/10/offer-30/"/>
    <id>http://nichunen.github.io/2023/01/10/offer-30/</id>
    <published>2023-01-10T03:01:04.000Z</published>
    <updated>2023-01-10T07:47:10.731Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-29</title>
    <link href="http://nichunen.github.io/2023/01/09/offer-29/"/>
    <id>http://nichunen.github.io/2023/01/09/offer-29/</id>
    <published>2023-01-09T09:09:07.000Z</published>
    <updated>2023-01-09T09:37:36.882Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-28</title>
    <link href="http://nichunen.github.io/2023/01/06/offer-28/"/>
    <id>http://nichunen.github.io/2023/01/06/offer-28/</id>
    <published>2023-01-06T03:18:57.000Z</published>
    <updated>2023-01-06T03:51:50.321Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 [1,2,2,3,4,4,3] 是对称的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;    1    / \   2   2  / \ / \ 3  4 4 </summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-27</title>
    <link href="http://nichunen.github.io/2023/01/05/offer-27/"/>
    <id>http://nichunen.github.io/2023/01/05/offer-27/</id>
    <published>2023-01-05T06:50:09.000Z</published>
    <updated>2023-01-05T07:13:34.065Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请完成一个函数，输入一个二叉树，该函数输出它的镜像。&lt;/p&gt;
&lt;p&gt;例如输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;     4    /   \   2     7  / \   / \ 1   3 6   9&lt;/code&gt;&lt;br&gt;镜像输出：&lt;/p&gt;
&lt;pre</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>offer-26</title>
    <link href="http://nichunen.github.io/2023/01/04/offer-26/"/>
    <id>http://nichunen.github.io/2023/01/04/offer-26/</id>
    <published>2023-01-04T06:05:57.000Z</published>
    <updated>2023-01-04T07:01:48.182Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有出现和B相同的结构和节点值。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定的树 A:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;     3     / \    4   5 </summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://nichunen.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
